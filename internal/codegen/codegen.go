package codegen

import (
	"fmt"

	"github.com/dave/jennifer/jen"
	"github.com/sidkurella/gunion/internal/config"
	"github.com/sidkurella/gunion/internal/types"
)

// TODO: Add more details to the preamble, such as the command / version used to generate the file.
const preamble string = "// Code generated by gunion. DO NOT EDIT.\n\n"

const variantNameTemplate = `_%sVariant`
const isVariantNameTemplate = `Is%s`
const unwrapVariantNameTemplate = `Unwrap%s`
const constructorNameTemplate = `New%s_%s`

type variant struct {
	name      string
	constName string
	// TODO: Type info for setter/getter
}

type CodeGenerator struct {
	config config.OutputConfig
}

func NewCodeGenerator(c config.OutputConfig) *CodeGenerator {
	return &CodeGenerator{
		config: c,
	}
}

func (c *CodeGenerator) Generate(t types.Named) error {
	// Validate that the provided type is a struct.
	if _, ok := t.Type.(types.Struct); !ok {
		return fmt.Errorf("expected a struct type, got %T", t.Type)
	}

	outFile := jen.NewFilePathName(t.Package, c.config.OutPkg)
	outFile.HeaderComment(preamble)

	variantTypeName := fmt.Sprintf(variantNameTemplate, t.Name)
	outFile.Type().Id(variantTypeName).Int().Line()

	variants := make([]variant, 0, len(t.Type.(types.Struct).Fields))
	if !c.config.Default { // Insert default invalid variant at beginning
		variants = append(variants, variant{
			name:      "Invalid",
			constName: variantTypeName + "__invalid",
		})
	}

	for _, field := range t.Type.(types.Struct).Fields {
		variants = append(variants, variant{
			name:      field.Var.Name,
			constName: variantTypeName + "_" + field.Var.Name,
		})
	}

	outFile.Const().DefsFunc(func(g *jen.Group) {
		for i, variant := range variants {
			// Could also use iota here, but this is more explicit and easier to generate.
			g.Id(variant.constName).Qual(t.Package, variantTypeName).Op("=").Lit(i)
		}
	})

	inner := jen.Id("inner").Qual(t.Package, t.Name)
	if c.config.PublicValue {
		// Just embedding the struct directly - fields will be promoted and accessible as public
		inner = jen.Qual(t.Package, t.Name)
	}

	// TODO: Support for generics/type parameters
	outFile.Type().Id(c.config.OutType).Struct(
		jen.Id("variant").Qual(t.Package, variantTypeName),
		inner,
	)

	for _, variant := range variants {
		if c.config.Getters {
			generateGetter(variant, outFile)
		}
		if c.config.Setters {
			generateSetter(variant, outFile)
		}
	}

	fmt.Printf("%#v\n", outFile)

	// Write the generated code to the output file.
	err := outFile.Save(c.config.OutFile)
	if err != nil {
		return fmt.Errorf("failed to save generated code: %w", err)
	}

	return nil
}

// TODO: Rename from getter to Unwrap
func generateGetter(v variant, outFile *jen.File) {
	// If and Unwrap
}

// TODO: Rename from setter to Constructor
func generateSetter(v variant, outFile *jen.File) {
	// More accurately constructors
}
