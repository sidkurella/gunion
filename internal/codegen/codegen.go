package codegen

import (
	"fmt"

	"github.com/dave/jennifer/jen"
	"github.com/sidkurella/gunion/internal/config"
	"github.com/sidkurella/gunion/internal/types"
)

const preambleTemplate string = "// Code generated by gunion%s. DO NOT EDIT.\n\n"

const variantNameTemplate = `_%sVariant`
const isVariantNameTemplate = `Is_%s`
const unwrapVariantNameTemplate = `Unwrap_%s`
const getVariantNameTemplate = `Get_%s`
const constructorNameTemplate = `New%s_%s`
const matchFuncNameTemplate = `Match_%s`
const matchArmNameTemplate = `on_%s`

type variant struct {
	name      string
	constName string
	// The field on the inner struct this variant corresponds to. Nil for the Invalid variant.
	field *types.Field
	// jen.Code representation of the field type. Nil for the Invalid variant.
	typeCode *jen.Statement
}

// structFields holds the generated field names for the union struct.
// These are chosen to avoid collisions with the source struct's field names.
type structFields struct {
	variantField string // field name for the variant tag (default "_variant")
	innerField   string // field name for the embedded source struct (default "_inner")
	invalidName  string // variant name for the invalid/zero-value variant (default "Invalid")
}

// newStructFields picks field names for the generated union struct that don't
// collide with any of the source struct's field names. Starts with "_variant"
// and "_inner", prepending underscores until unique.
func newStructFields(sourceFields []types.Field) structFields {
	taken := make(map[string]bool, len(sourceFields))
	for _, f := range sourceFields {
		taken[f.Var.Name] = true
	}
	return structFields{
		variantField: uniqueName("_variant", taken),
		innerField:   uniqueName("_inner", taken),
		invalidName:  uniqueName("Invalid", taken),
	}
}

// uniqueName returns candidate if it's not in taken, otherwise prepends
// underscores until a unique name is found.
func uniqueName(candidate string, taken map[string]bool) string {
	for taken[candidate] {
		candidate = "_" + candidate
	}
	return candidate
}

// genericsInfo holds pre-computed jen code for generic type parameters.
// All fields are nil/empty when the source type is not generic.
type genericsInfo struct {
	// Type parameter definitions with constraints, e.g. [T any, U comparable].
	// Used on type definitions and standalone functions (constructors, Match).
	typeParamDefs []jen.Code
	// Type argument names only, e.g. [T, U].
	// Used when instantiating the type (inner field, return types, receiver).
	typeArgs []jen.Code
	// The name chosen for Match's result type parameter, guaranteed unique.
	matchResultParam string
}

// newGenericsInfo builds genericsInfo from the source type's type parameters.
// Returns an empty genericsInfo if typeParams is empty (non-generic type).
func newGenericsInfo(typeParams []types.TypeParam) (genericsInfo, error) {
	if len(typeParams) == 0 {
		return genericsInfo{}, nil
	}

	info := genericsInfo{}
	names := make(map[string]bool, len(typeParams))

	for _, tp := range typeParams {
		names[tp.Name] = true
		constraint, err := typeToCode(tp.Constraint)
		if err != nil {
			return genericsInfo{}, fmt.Errorf("failed to convert constraint for type param %s: %w", tp.Name, err)
		}
		info.typeParamDefs = append(info.typeParamDefs, jen.Id(tp.Name).Add(constraint))
		info.typeArgs = append(info.typeArgs, jen.Id(tp.Name))
	}

	// Pick a unique name for Match's result type param.
	candidate := "_R"
	for names[candidate] {
		candidate = "_" + candidate
	}
	info.matchResultParam = candidate

	return info, nil
}

// receiverType builds the receiver expression: *OutType or *OutType[T, U].
func (g *genericsInfo) receiverType(outType string) *jen.Statement {
	stmt := jen.Id("u").Op("*").Id(outType)
	if len(g.typeArgs) > 0 {
		stmt = stmt.Types(g.typeArgs...)
	}
	return stmt
}

// returnType builds the return type expression: OutType or OutType[T, U].
func (g *genericsInfo) returnType(outType string) *jen.Statement {
	stmt := jen.Id(outType)
	if len(g.typeArgs) > 0 {
		stmt = stmt.Types(g.typeArgs...)
	}
	return stmt
}

type CodeGenerator struct {
	config config.OutputConfig
}

func NewCodeGenerator(c config.OutputConfig) *CodeGenerator {
	return &CodeGenerator{
		config: c,
	}
}

func (c *CodeGenerator) Generate(t types.Named) error {
	// Validate that the provided type is a struct.
	s, ok := t.Type.(types.Struct)
	if !ok {
		return fmt.Errorf("expected a struct type, got %T", t.Type)
	}

	sf := newStructFields(s.Fields)

	gi, err := newGenericsInfo(t.TypeParams)
	if err != nil {
		return err
	}

	outFile := jen.NewFilePathName(t.Package, c.config.OutPkg)
	commandSuffix := ""
	if c.config.Command != "" {
		commandSuffix = " via `" + c.config.Command + "`"
	}
	outFile.HeaderComment(fmt.Sprintf(preambleTemplate, commandSuffix))

	variantTypeName := fmt.Sprintf(variantNameTemplate, t.Name)
	outFile.Type().Id(variantTypeName).Int().Line()

	variants := make([]variant, 0, len(s.Fields))
	if !c.config.Default { // Insert default invalid variant at beginning
		variants = append(variants, variant{
			name:      sf.invalidName,
			constName: variantTypeName + "_" + sf.invalidName,
		})
	}

	for _, field := range s.Fields {
		code, err := typeToCode(field.Var.Type)
		if err != nil {
			return fmt.Errorf("failed to convert type for field %s: %w", field.Var.Name, err)
		}
		f := field // copy for pointer stability
		variants = append(variants, variant{
			name:      field.Var.Name,
			constName: variantTypeName + "_" + field.Var.Name,
			field:     &f,
			typeCode:  code,
		})
	}

	outFile.Const().DefsFunc(func(g *jen.Group) {
		for i, variant := range variants {
			// Could also use iota here, but this is more explicit and easier to generate.
			g.Id(variant.constName).Qual(t.Package, variantTypeName).Op("=").Lit(i)
		}
	})

	generateStringer(variants, variantTypeName, outFile)

	// Build inner field: _inner myUnion or _inner myUnion[T, U].
	innerType := jen.Qual(t.Package, t.Name)
	if len(gi.typeArgs) > 0 {
		innerType = innerType.Types(gi.typeArgs...)
	}
	inner := jen.Id(sf.innerField).Add(innerType)

	// Build type definition: type OutType struct or type OutType[T any, U comparable] struct.
	typeDef := outFile.Type().Id(c.config.OutType)
	if len(gi.typeParamDefs) > 0 {
		typeDef = typeDef.Types(gi.typeParamDefs...)
	}
	typeDef.Struct(
		jen.Id(sf.variantField).Qual(t.Package, variantTypeName),
		inner,
	)

	for _, variant := range variants {
		if c.config.Getters {
			generateIs(variant, c.config.OutType, &sf, &gi, outFile)
			// Unwrap/Get only make sense for variants that have a type (not Invalid).
			if variant.field != nil {
				generateUnwrap(variant, c.config.OutType, &sf, &gi, outFile)
				generateGet(variant, c.config.OutType, &sf, &gi, outFile)
			}
		}
		if c.config.Setters {
			generateConstructor(variant, c.config.OutType, t, &sf, &gi, outFile)
		}
	}

	if c.config.Match {
		generateMatch(variants, c.config.OutType, &sf, &gi, outFile)
	}

	// Write the generated code to the output file.
	err = outFile.Save(c.config.OutFile)
	if err != nil {
		return fmt.Errorf("failed to save generated code: %w", err)
	}

	return nil
}

// generateStringer generates a String() method on the variant enum type.
//
//	func (v _myUnionVariant) String() string {
//	    switch v {
//	    case _myUnionVariant_a:
//	        return "a"
//	    default:
//	        return "unknown"
//	    }
//	}
func generateStringer(variants []variant, variantTypeName string, outFile *jen.File) {
	var cases []jen.Code
	for _, v := range variants {
		cases = append(cases, jen.Case(jen.Id(v.constName)).Block(
			jen.Return(jen.Lit(v.name)),
		))
	}
	cases = append(cases, jen.Default().Block(
		jen.Return(jen.Lit("unknown")),
	))

	outFile.Func().Params(
		jen.Id("v").Id(variantTypeName),
	).Id("String").Params().String().Block(
		jen.Switch(jen.Id("v")).Block(cases...),
	).Line()
}

// generateIs generates the Is_<Variant> method on the union type.
//
//	func (u *OutType[T, U]) Is_<Variant>() bool {
//	    return u.variant == <constName>
//	}
func generateIs(v variant, outType string, sf *structFields, gi *genericsInfo, outFile *jen.File) {
	methodName := fmt.Sprintf(isVariantNameTemplate, v.name)
	outFile.Func().Params(
		gi.receiverType(outType),
	).Id(methodName).Params().Bool().Block(
		jen.Return(jen.Id("u").Dot(sf.variantField).Op("==").Id(v.constName)),
	).Line()
}

// generateUnwrap generates the Unwrap_<Variant> method on the union type.
// Panics if the union is not the expected variant (similar to Rust's unwrap semantics).
//
//	func (u *OutType[T, U]) Unwrap_<Variant>() <Type> {
//	    if u.variant != <constName> {
//	        panic("unwrap called on wrong variant")
//	    }
//	    return u.inner.<Variant>
//	}
func generateUnwrap(v variant, outType string, sf *structFields, gi *genericsInfo, outFile *jen.File) {
	methodName := fmt.Sprintf(unwrapVariantNameTemplate, v.name)

	// Access path to the field: u._inner.<Name>.
	fieldAccess := jen.Id("u").Dot(sf.innerField).Dot(v.name)

	outFile.Func().Params(
		gi.receiverType(outType),
	).Id(methodName).Params().Add(v.typeCode).Block(
		jen.If(jen.Id("u").Dot(sf.variantField).Op("!=").Id(v.constName)).Block(
			jen.Panic(jen.Lit(fmt.Sprintf("called %s on wrong variant", methodName))),
		),
		jen.Return(fieldAccess),
	).Line()
}

// generateGet generates the Get_<Variant> method on the union type.
// Returns the value and a bool indicating whether the variant matched.
//
//	func (u *OutType[T, U]) Get_<Variant>() (<Type>, bool) {
//	    if u.variant == <constName> {
//	        return u.inner.<Variant>, true
//	    }
//	    var zero <Type>
//	    return zero, false
//	}
func generateGet(v variant, outType string, sf *structFields, gi *genericsInfo, outFile *jen.File) {
	methodName := fmt.Sprintf(getVariantNameTemplate, v.name)

	// Access path to the field: u._inner.<Name>.
	fieldAccess := jen.Id("u").Dot(sf.innerField).Dot(v.name)

	outFile.Func().Params(
		gi.receiverType(outType),
	).Id(methodName).Params().Params(v.typeCode, jen.Bool()).Block(
		jen.If(jen.Id("u").Dot(sf.variantField).Op("==").Id(v.constName)).Block(
			jen.Return(fieldAccess, jen.True()),
		),
		jen.Var().Id("zero").Add(v.typeCode),
		jen.Return(jen.Id("zero"), jen.False()),
	).Line()
}

// generateMatch generates a generic Match function for exhaustive pattern matching.
// Real variant arms come first; the Invalid arm (if present) comes last.
// All arms must be explicitly handled.
//
// For non-generic types:
//
//	func Match_OutType[_R any](u *OutType, on_a func(int) _R, on_Invalid func() _R) _R { ... }
//
// For generic types:
//
//	func Match_OutType[T any, U comparable, _R any](u *OutType[T, U], on_a func(T) _R, on_Invalid func() _R) _R { ... }
func generateMatch(variants []variant, outType string, sf *structFields, gi *genericsInfo, outFile *jen.File) {
	// Reorder: real variants first, invalid last.
	var realVariants []variant
	var invalidVariant *variant
	for i := range variants {
		if variants[i].field == nil {
			invalidVariant = &variants[i]
		} else {
			realVariants = append(realVariants, variants[i])
		}
	}
	ordered := realVariants
	if invalidVariant != nil {
		ordered = append(ordered, *invalidVariant)
	}

	// Result type param name (unique from source type params).
	resultParam := gi.matchResultParam
	if resultParam == "" {
		resultParam = "_R"
	}

	// Build type param list: source type params + result param.
	matchTypeParams := make([]jen.Code, 0, len(gi.typeParamDefs)+1)
	matchTypeParams = append(matchTypeParams, gi.typeParamDefs...)
	matchTypeParams = append(matchTypeParams, jen.Id(resultParam).Any())

	// Build parameter list: u *OutType[T, U], then one func param per variant.
	uParam := jen.Id("u").Op("*").Id(outType)
	if len(gi.typeArgs) > 0 {
		uParam = uParam.Types(gi.typeArgs...)
	}
	params := []jen.Code{uParam}
	for _, v := range ordered {
		armName := fmt.Sprintf(matchArmNameTemplate, v.name)
		if v.field != nil {
			params = append(params, jen.Id(armName).Func().Params(v.typeCode).Id(resultParam))
		} else {
			params = append(params, jen.Id(armName).Func().Params().Id(resultParam))
		}
	}

	// Build switch cases.
	var cases []jen.Code
	for _, v := range ordered {
		armName := fmt.Sprintf(matchArmNameTemplate, v.name)
		var callExpr *jen.Statement
		if v.field != nil {
			fieldAccess := jen.Id("u").Dot(sf.innerField).Dot(v.name)
			callExpr = jen.Id(armName).Call(fieldAccess)
		} else {
			callExpr = jen.Id(armName).Call()
		}
		cases = append(cases, jen.Case(jen.Id(v.constName)).Block(
			jen.Return(callExpr),
		))
	}
	cases = append(cases, jen.Default().Block(
		jen.Panic(jen.Lit("unreachable")),
	))

	matchFuncName := fmt.Sprintf(matchFuncNameTemplate, outType)
	outFile.Func().Id(matchFuncName).Types(matchTypeParams...).Params(params...).Id(resultParam).Block(
		jen.Switch(jen.Id("u").Dot(sf.variantField)).Block(cases...),
	).Line()
}

// generateConstructor generates a constructor function for a variant.
//
// For non-generic real variants:
//
//	func NewOutType_a(val int) OutType { ... }
//
// For generic real variants:
//
//	func NewOutType_a[T any, U comparable](val T) OutType[T, U] { ... }
//
// For the Invalid variant (non-generic):
//
//	func NewOutType_Invalid() OutType { ... }
//
// For the Invalid variant (generic):
//
//	func NewOutType_Invalid[T any, U comparable]() OutType[T, U] { ... }
func generateConstructor(v variant, outType string, source types.Named, sf *structFields, gi *genericsInfo, outFile *jen.File) {
	funcName := fmt.Sprintf(constructorNameTemplate, outType, v.name)

	// Source type instantiation: myUnion or myUnion[T, U].
	sourceType := jen.Qual(source.Package, source.Name)
	if len(gi.typeArgs) > 0 {
		sourceType = sourceType.Types(gi.typeArgs...)
	}

	if v.field == nil {
		// Invalid variant: no value parameters.
		funcDef := outFile.Func().Id(funcName)
		if len(gi.typeParamDefs) > 0 {
			funcDef = funcDef.Types(gi.typeParamDefs...)
		}
		funcDef.Params().Add(gi.returnType(outType)).Block(
			jen.Return(gi.returnType(outType).Values(jen.Dict{
				jen.Id(sf.variantField): jen.Id(v.constName),
			})),
		).Line()
		return
	}

	funcDef := outFile.Func().Id(funcName)
	if len(gi.typeParamDefs) > 0 {
		funcDef = funcDef.Types(gi.typeParamDefs...)
	}
	funcDef.Params(
		jen.Id("val").Add(v.typeCode),
	).Add(gi.returnType(outType)).Block(
		jen.Return(gi.returnType(outType).Values(jen.Dict{
			jen.Id(sf.variantField): jen.Id(v.constName),
			jen.Id(sf.innerField): sourceType.Values(jen.Dict{
				jen.Id(v.name): jen.Id("val"),
			}),
		})),
	).Line()
}

// typeToCode converts a types.Type to the appropriate jen.Code representation.
func typeToCode(t types.Type) (*jen.Statement, error) {
	switch typ := t.(type) {
	case types.Basic:
		return jen.Id(typ.Name), nil

	case types.Named:
		// Built-in types (any, comparable, error) have empty package paths.
		var stmt *jen.Statement
		if typ.Package == "" {
			stmt = jen.Id(typ.Name)
		} else {
			stmt = jen.Qual(typ.Package, typ.Name)
		}
		if len(typ.TypeArgs) > 0 {
			var err error
			stmt = stmt.TypesFunc(func(g *jen.Group) {
				for _, arg := range typ.TypeArgs {
					code, e := typeToCode(arg)
					if e != nil {
						err = e
						return
					}
					g.Add(code)
				}
			})
			if err != nil {
				return nil, err
			}
		}
		return stmt, nil

	case types.Pointer:
		elem, err := typeToCode(typ.Elem)
		if err != nil {
			return nil, err
		}
		return jen.Op("*").Add(elem), nil

	case types.Slice:
		elem, err := typeToCode(typ.Elem)
		if err != nil {
			return nil, err
		}
		return jen.Index().Add(elem), nil

	case types.Array:
		elem, err := typeToCode(typ.Elem)
		if err != nil {
			return nil, err
		}
		return jen.Index(jen.Lit(int(typ.Len))).Add(elem), nil

	case types.Map:
		key, err := typeToCode(typ.Key)
		if err != nil {
			return nil, err
		}
		value, err := typeToCode(typ.Value)
		if err != nil {
			return nil, err
		}
		return jen.Map(key).Add(value), nil

	case types.Chan:
		elem, err := typeToCode(typ.Elem)
		if err != nil {
			return nil, err
		}
		switch typ.Direction {
		case types.SendOnly:
			return jen.Chan().Op("<-").Add(elem), nil
		case types.RecvOnly:
			return jen.Op("<-").Chan().Add(elem), nil
		default: // SendRecv
			return jen.Chan().Add(elem), nil
		}

	case types.Struct:
		var err error
		stmt := jen.StructFunc(func(g *jen.Group) {
			for _, field := range typ.Fields {
				code, e := typeToCode(field.Var.Type)
				if e != nil {
					err = e
					return
				}
				g.Id(field.Var.Name).Add(code)
			}
		})
		if err != nil {
			return nil, err
		}
		return stmt, nil

	case types.Interface:
		var err error
		stmt := jen.InterfaceFunc(func(g *jen.Group) {
			for _, embed := range typ.Embeds {
				code, e := typeToCode(embed)
				if e != nil {
					err = e
					return
				}
				g.Add(code)
			}
			for _, method := range typ.Methods {
				code, e := signatureToCode(method.Signature)
				if e != nil {
					err = e
					return
				}
				g.Id(method.Name).Add(code)
			}
		})
		if err != nil {
			return nil, err
		}
		return stmt, nil

	case types.Union:
		var err error
		stmt := jen.UnionFunc(func(g *jen.Group) {
			for _, member := range typ.Members {
				code, e := typeToCode(member.Type)
				if e != nil {
					err = e
					return
				}
				if member.Approximate {
					g.Op("~").Add(code)
				} else {
					g.Add(code)
				}
			}
		})
		if err != nil {
			return nil, err
		}
		return stmt, nil

	case types.Signature:
		return signatureToCode(typ)

	case types.TypeParam:
		return jen.Id(typ.Name), nil

	default:
		return nil, fmt.Errorf("unsupported type: %T", t)
	}
}

// signatureToCode converts a types.Signature to jen.Code for a function type (params and returns only).
// Returns an error if the signature has receivers or type parameters, as those are not valid for function types.
func signatureToCode(sig types.Signature) (*jen.Statement, error) {
	if sig.Receiver.Type != nil {
		return nil, fmt.Errorf("function types cannot have receivers")
	}
	if len(sig.ReceiverTypeParams) > 0 {
		return nil, fmt.Errorf("function types cannot have receiver type parameters")
	}
	if len(sig.TypeParams) > 0 {
		return nil, fmt.Errorf("function types cannot have type parameters")
	}

	var err error
	stmt := jen.ParamsFunc(func(g *jen.Group) {
		for i, param := range sig.Params {
			// Handle variadic: last param with Variadic flag
			if sig.Variadic && i == len(sig.Params)-1 {
				// Variadic param: extract slice element type
				if slice, ok := param.Type.(types.Slice); ok {
					code, e := typeToCode(slice.Elem)
					if e != nil {
						err = e
						return
					}
					g.Id(param.Name).Op("...").Add(code)
				} else {
					code, e := typeToCode(param.Type)
					if e != nil {
						err = e
						return
					}
					g.Id(param.Name).Add(code)
				}
			} else {
				code, e := typeToCode(param.Type)
				if e != nil {
					err = e
					return
				}
				g.Id(param.Name).Add(code)
			}
		}
	}).ParamsFunc(func(g *jen.Group) {
		for _, ret := range sig.Returns {
			code, e := typeToCode(ret.Type)
			if e != nil {
				err = e
				return
			}
			if ret.Name != "" {
				g.Id(ret.Name).Add(code)
			} else {
				g.Add(code)
			}
		}
	})
	if err != nil {
		return nil, err
	}
	return stmt, nil
}
