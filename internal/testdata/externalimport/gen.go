// Code generated by gunion. DO NOT EDIT.

package externalimport

import (
	"context"
	packages "golang.org/x/tools/go/packages"
)

type _myUnionVariant int

const (
	_myUnionVariant_Invalid _myUnionVariant = 0
	_myUnionVariant_a       _myUnionVariant = 1
	_myUnionVariant_b       _myUnionVariant = 2
	_myUnionVariant_c       _myUnionVariant = 3
)

func (v _myUnionVariant) String() string {
	switch v {
	case _myUnionVariant_Invalid:
		return "Invalid"
	case _myUnionVariant_a:
		return "a"
	case _myUnionVariant_b:
		return "b"
	case _myUnionVariant_c:
		return "c"
	default:
		return "unknown"
	}
}

type MyUnionUnion struct {
	_variant _myUnionVariant
	_inner   myUnion
}

func (u *MyUnionUnion) Is_Invalid() bool {
	return u._variant == _myUnionVariant_Invalid
}

func NewMyUnionUnion_Invalid() MyUnionUnion {
	return MyUnionUnion{_variant: _myUnionVariant_Invalid}
}

func (u *MyUnionUnion) Is_a() bool {
	return u._variant == _myUnionVariant_a
}

func (u *MyUnionUnion) Unwrap_a() int {
	if u._variant != _myUnionVariant_a {
		panic("called Unwrap_a on wrong variant")
	}
	return u._inner.a
}

func (u *MyUnionUnion) Get_a() (int, bool) {
	if u._variant == _myUnionVariant_a {
		return u._inner.a, true
	}
	var zero int
	return zero, false
}

func NewMyUnionUnion_a(val int) MyUnionUnion {
	return MyUnionUnion{
		_inner:   myUnion{a: val},
		_variant: _myUnionVariant_a,
	}
}

func (u *MyUnionUnion) Is_b() bool {
	return u._variant == _myUnionVariant_b
}

func (u *MyUnionUnion) Unwrap_b() *packages.Package {
	if u._variant != _myUnionVariant_b {
		panic("called Unwrap_b on wrong variant")
	}
	return u._inner.b
}

func (u *MyUnionUnion) Get_b() (*packages.Package, bool) {
	if u._variant == _myUnionVariant_b {
		return u._inner.b, true
	}
	var zero *packages.Package
	return zero, false
}

func NewMyUnionUnion_b(val *packages.Package) MyUnionUnion {
	return MyUnionUnion{
		_inner:   myUnion{b: val},
		_variant: _myUnionVariant_b,
	}
}

func (u *MyUnionUnion) Is_c() bool {
	return u._variant == _myUnionVariant_c
}

func (u *MyUnionUnion) Unwrap_c() context.Context {
	if u._variant != _myUnionVariant_c {
		panic("called Unwrap_c on wrong variant")
	}
	return u._inner.c
}

func (u *MyUnionUnion) Get_c() (context.Context, bool) {
	if u._variant == _myUnionVariant_c {
		return u._inner.c, true
	}
	var zero context.Context
	return zero, false
}

func NewMyUnionUnion_c(val context.Context) MyUnionUnion {
	return MyUnionUnion{
		_inner:   myUnion{c: val},
		_variant: _myUnionVariant_c,
	}
}

func Match_MyUnionUnion[_R any](u *MyUnionUnion, on_a func(int) _R, on_b func(*packages.Package) _R, on_c func(context.Context) _R, on_Invalid func() _R) _R {
	switch u._variant {
	case _myUnionVariant_a:
		return on_a(u._inner.a)
	case _myUnionVariant_b:
		return on_b(u._inner.b)
	case _myUnionVariant_c:
		return on_c(u._inner.c)
	case _myUnionVariant_Invalid:
		return on_Invalid()
	default:
		panic("unreachable")
	}
}
