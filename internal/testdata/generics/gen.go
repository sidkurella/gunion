// Code generated by gunion. DO NOT EDIT.

package generics

import "io"

type _myUnionVariant int

const (
	_myUnionVariant_Invalid _myUnionVariant = 0
	_myUnionVariant_a       _myUnionVariant = 1
	_myUnionVariant_b       _myUnionVariant = 2
	_myUnionVariant_c       _myUnionVariant = 3
)

func (v _myUnionVariant) String() string {
	switch v {
	case _myUnionVariant_Invalid:
		return "Invalid"
	case _myUnionVariant_a:
		return "a"
	case _myUnionVariant_b:
		return "b"
	case _myUnionVariant_c:
		return "c"
	default:
		return "unknown"
	}
}

type MyUnionUnion[T any, U comparable, V io.Writer] struct {
	_variant _myUnionVariant
	_inner   myUnion[T, U, V]
}

func (u *MyUnionUnion[T, U, V]) Is_Invalid() bool {
	return u._variant == _myUnionVariant_Invalid
}

func NewMyUnionUnion_Invalid[T any, U comparable, V io.Writer]() MyUnionUnion[T, U, V] {
	return MyUnionUnion[T, U, V]{_variant: _myUnionVariant_Invalid}
}

func (u *MyUnionUnion[T, U, V]) Is_a() bool {
	return u._variant == _myUnionVariant_a
}

func (u *MyUnionUnion[T, U, V]) Unwrap_a() T {
	if u._variant != _myUnionVariant_a {
		panic("called Unwrap_a on wrong variant")
	}
	return u._inner.a
}

func (u *MyUnionUnion[T, U, V]) Get_a() (T, bool) {
	if u._variant == _myUnionVariant_a {
		return u._inner.a, true
	}
	var zero T
	return zero, false
}

func NewMyUnionUnion_a[T any, U comparable, V io.Writer](val T) MyUnionUnion[T, U, V] {
	return MyUnionUnion[T, U, V]{
		_inner:   myUnion[T, U, V]{a: val},
		_variant: _myUnionVariant_a,
	}
}

func (u *MyUnionUnion[T, U, V]) Is_b() bool {
	return u._variant == _myUnionVariant_b
}

func (u *MyUnionUnion[T, U, V]) Unwrap_b() U {
	if u._variant != _myUnionVariant_b {
		panic("called Unwrap_b on wrong variant")
	}
	return u._inner.b
}

func (u *MyUnionUnion[T, U, V]) Get_b() (U, bool) {
	if u._variant == _myUnionVariant_b {
		return u._inner.b, true
	}
	var zero U
	return zero, false
}

func NewMyUnionUnion_b[T any, U comparable, V io.Writer](val U) MyUnionUnion[T, U, V] {
	return MyUnionUnion[T, U, V]{
		_inner:   myUnion[T, U, V]{b: val},
		_variant: _myUnionVariant_b,
	}
}

func (u *MyUnionUnion[T, U, V]) Is_c() bool {
	return u._variant == _myUnionVariant_c
}

func (u *MyUnionUnion[T, U, V]) Unwrap_c() V {
	if u._variant != _myUnionVariant_c {
		panic("called Unwrap_c on wrong variant")
	}
	return u._inner.c
}

func (u *MyUnionUnion[T, U, V]) Get_c() (V, bool) {
	if u._variant == _myUnionVariant_c {
		return u._inner.c, true
	}
	var zero V
	return zero, false
}

func NewMyUnionUnion_c[T any, U comparable, V io.Writer](val V) MyUnionUnion[T, U, V] {
	return MyUnionUnion[T, U, V]{
		_inner:   myUnion[T, U, V]{c: val},
		_variant: _myUnionVariant_c,
	}
}

func Match_MyUnionUnion[T any, U comparable, V io.Writer, _R any](u *MyUnionUnion[T, U, V], on_a func(T) _R, on_b func(U) _R, on_c func(V) _R, on_Invalid func() _R) _R {
	switch u._variant {
	case _myUnionVariant_a:
		return on_a(u._inner.a)
	case _myUnionVariant_b:
		return on_b(u._inner.b)
	case _myUnionVariant_c:
		return on_c(u._inner.c)
	case _myUnionVariant_Invalid:
		return on_Invalid()
	default:
		panic("unreachable")
	}
}
